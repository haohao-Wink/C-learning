## 命名空间
### 1.为什么要使用命名空间？
    名字冲突：在同一个作用域中有两个或多个同名的实体
    命名空间：一个可以由用户定义的作用域，在不同的作用域中可以定义相同的名字变量，互不干扰
### 2.什么是命名空间？
    每个命名空间都是一个命名空间域，存放在命名空间中的全局实体只在本空间域内有效

    C++中定义命名空间的基本格式：
    ``` 
    namespace aa{
        int val1=0;
        char val2;
    }//end of namespace aa
    ``` 

    在声明一个命名空间时，大括号内不仅可以存放变量，还可以存放以下类型：变量、常量、函数（也可以是定义或者声明）、结构体、类、模板、命名空间（可以嵌套定义）
    ```
    namespace aa{
        int num=0;
        struct A{
            char ch;int val;
        };
        
        void display();
    }//end of namespace aa
    ``` 
#### 注意：
    1. 定义在命名空间中的变量或者函数都称为实体，名称空间中的实体作用域是全局的，并不意味着可见域是全局
    2. 如果不使用作用域限定符和using机制，实体的可见域生存周期从实体创建到该名称空间结束
    3. 在名称空间外，实体不可见

### 3.命名空间使用方式
#### 3.1 using 编译指令
    ```
    //最经典的using编译指令，可能会导致命名冲突
    //std代表标准命名空间
    using namespace std;

    ```
#### 3.2 作用域限定符
    `::`

    ```
    namespace aa{
        int num=10;
        void display(){
            
            //其中，cout、endl都是std空间的实体，所以添加"std::"命名空间           
            std::cout <<"aa::display()" <<std::endl;
        }
    }//end of namespace aa
    ```

 #### 3.3 using声明机制
    using声明机制的作用域从using语句开始，到using所在的作用域结束。
    **注：在同一作用域内用using声明的不同的命名空间的成员不能有同名成员，否则发生重定义**
    
    ```
    using std :: cout;
    using std :: endl;
    ```   

### 4.匿名命名空间
    命名空间中，不定义名字的命名空间
    特点：
        该空间中的实体，其他文件无法引用，只在本文件的作用域内有效
        作用域为匿名命名空间声明开始到本文件结束

     ```
     namespace{
        int val1=10;
        void func();
     }//end of anonymous namespace
     ```   

    在匿名命名空间中创建的全局变量，具有全局生存期，却只能被本空间内的函数访问，是static变量的有效替代手段

### 5.对命名空间的总结
    1.提倡在已命名的名称空间中定义变量，而不是直接定义外部全局变量或者静态全局变量
    2.如果开发函数库或类库，提倡放在名称空间中
    3.对于using声明，首先将作用域设置为局部而不是全局
    4.不要再头文件中使用using编译指令，可能会使可用名称变得模糊，出现二义性
    5.包含头文件的顺序可能会影响程序的行为，如果非要使用using编译指令，建议放在所有#include预编译指令之后
