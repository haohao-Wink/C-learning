## 程序内存分配方式
### 程序内存布局
>内核态空间
>用户态空间
>>栈区：由编译器自动分配释放，存放函数的参数值，局部变量的值；操作方式类似于数据结构中的栈
>>堆区：由程序员分配释放，如果程序员不释放，程序结束时，由os回收。区别于数据结构中的堆，分配方式类似于链表
>>全局/静态区：全局变量和静态变量存储在一起，在程序编译时分配
>>文字常量区：存放常量字符串
>>程序代码区：存放函数体（类的成员函数、全局函数）的二进制代码

### 栈和堆的比较
1.申请后的系统响应
>栈:只要栈的剩余空间大于所申请的空间，系统为程序提供内存，否则将提示栈溢出
>堆：
>>当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该节点从空闲结点链表中删除，并将该节点的空间分配给程序
>>对于大多数系统，首地址会记录这块内存空间中本次分配的大小，有利于delete释放内存空间
>>由于找到的堆结点的大小不一定等于申请大小，系统会将多余部分重新放回空闲链表中

2.申请的效率比较
>栈由系统自动分配，速度较快，但程序员不可控
>堆由new分配的内存，一般速度较慢，且容易产生内存碎片

3.申请的大小限制
>栈：
>>在win中，栈是向低地址扩展的数据结构，是一块连续的内存区域，也就是栈顶的地址和栈的最大容量是系统预先规定好的
>>如果申请的空间超过栈的剩余空间，会提示overflow，因此能从栈中获得的空间较小

>堆：
>>堆是向高地址扩展的数据结构，是不连续的内存区域
>>系统用链表来存储空闲的内存地址，所以是不连续的；链表的遍历方向是由低地址到高地址

4.堆和栈中的存储内容
>栈：
>>在函数调用时，第一个进栈的是主函数的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数
>>本次函数调用结束，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行

>堆:
>>一般是在堆的头部用一个字节存放堆的大小
>>堆中的具体内容由程序员安排

### 栈和堆的区别
1.管理方式不同。
>对于栈来说，由编译器自动管理；对于堆来说，释放工作由程序员控制，容易产生memory leak
2.空间大小不同。
>对于堆来说，堆内存一般没有什么限制；对于栈来讲，一般都是有一定的空间大小的
3.分配方式不同。
>堆都是动态分配；栈的动态分配由编译器进行释放
4.生长方向。
>对于堆来说，生长方向是向上的，也即向内存地址增加的方向；对于栈来说，他的生长方向是向下的，也即向着内存地址减小的方向增长
5.碎片问题。
>对于堆来说，频繁的new/delete会使内存空间不连续，从而造成大量的碎片，是程序效率降低；对于栈来说，不会存在这个问题
