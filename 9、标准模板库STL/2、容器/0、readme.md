## 容器
### 序列式容器
#### 头文件
```
#include<vector>
#include<deque>
#include<list>
```

#### 初始化
1. 直接初始化为空
```
vector<int>num;
deque<int>num;
list<int>num;
```

2. 初始化为多个数据
```
vector <int> num(10,1);
deque<int>num (10,1);
list<int>num (10,1);
```

3. 使用迭代器范围
```
int arr[10]={1,2,3,4,5,6,7,8,9,10};
vector <int> num(arr,arr+10);//左闭右开区间
```

4. 使用大括号
```
vector <int> num ={1,2,3,4,5,6,7,8,9,10};
deque <int> num ={1,2,3,4,5,6,7,8,9,10};
list <int> num ={1,2,3,4,5,6,7,8,9,10};
```

#### 遍历
#### 尾部插入与删除
#### 头部插入与删除
#### 中间插入
#### 元素删除
#### 清空元素
#### 获取容器中元素个数和空间大小
#### list特殊操作
1. 排序函数sort()
2. 移出重复元素unique
3. 逆置链表中的元素reverse
4. 合并链表的函数merge
5. 从一个链表转移元素到另一个链表splice
6. 另外的插入方式emplace emplace_back

### 关联式容器
#### 初始化
使用形式与序列式容器完全一致

##### set特征：
1. 不能存放关键字key相同的元素，关键字必须唯一
2. 默认以升序进行排序
3. 底层实现是红黑树

##### 红黑树的五大特征
1. 结点不是黑色就是红色
2. 根节点是黑色
3. 叶子结点也是黑色
4. 如果一个结点是红色，那么他的左右孩子结点必须是黑色
5. 从根节点到叶子结点上所有路径要保证黑色结点的个数相同

##### multiset特征
1. 可以存放关键字key相同的元素，关键字不唯一
2. 默认以升序进行排序
3. 底层实现是红黑树

##### map的特征
1. 存放的是键值对，也就是pair 即`pair<const key,value>`，key值必须唯一，不能重复
2. 默认按照关键字key进行升序排序
3. 底层实现是红黑树

##### multimap特征
1. 存放的是键值对，也就是pair 即`pair<const key,value>`，key值不唯一，可以重复
2. 默认按照关键字key进行升序排序
3. 底层实现是红黑树

#### 遍历
#### 查找
#### 插入
#### 删除
#### 修改
#### 下标访问
#### 针对自定义类型的操作

### 无序关联式容器
#### 哈希函数
根据关键字key去寻找值的数据隐射，即根据key值找到key的对应存储位置
```
size_t index =H(key)//由关键字获取所在位置
```

#### 哈希函数的构造
1. 直接定值法：H(key)=a*key+b;
2. 平方取中法：key^2=1234^2=1522756------>227
3. 数字分析法：H(key)=key%1000;
4. 除留取余法：H(key)=keymod p(p<=m,m为表长)

#### 哈希冲突
对于不一样的key值，可以得到一样的地址

#### 解决哈希冲突的方案
1. 开放定址法
2. 链地址发（**）
3. 再散地址法
4. 建立公众溢出区

#### 装载因子
装载因子=实际装载数据长、表长
#### 哈希表设计思想
以空间换时间

### 容器适配器