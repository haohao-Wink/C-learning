## 模板
### 1.为什么要定义模板
1. 简化程序，少写代码，维持结构的清晰，大大提高程序的效率
2. 解决强类型语言的灵活性和严格性之间的冲突

>带参数的宏定义（原样替换）

>函数重载（函数名字不同，参数不同）

>模板（将数据类型作为参数）

3. 

> 强类型语言程序设计：C/C++/JAVA等，有严格的类型检查，在编译时明确变量的类型，如果有问题就可以在编译时发现错误，安全但是不够灵活

>弱类型程序语言设计：js/python等，虽然也有类型，但是在使用的时候直接使用，不知道变量的具体类型，由编译器进行解释变量类型，如果有错，直到运行时才能发现，虽然灵活但是不够安全

### 2. 模板的定义
```
template <class T, ...>
template <typename T, ...>
```
**注意：class与typename完全一致**

### 3. 模板的类型
#### 函数模板
** 通过参数实例化构造出具体的函数或类**

```
template <模板参数表> //模板参数列表，此处模板参数列表不能为空
返回类型 函数名（参数列表）
{
    //函数体
}
```

1. 实例化：隐式实例化和显示实例化
2. 函数目标、普通函数间的关系

>普通函数与普通模板是可以进行重载的

>普通函数优先于函数模板执行

>函数模板与函数模板之间也可以进行重载

3. 模板头文件与实现文件
模板不能写成头文件与实现文件的形式，或者说不能将声明和实现分开，否则会导致编译错误

4. 模板的特化：全特化与偏特化

5. 函数目标的参数类型

> 参数类型：

>非参数类型 常量表达式、整型:bool/char/short/int/long/size_t

6. 成员函数模板

类的成员函数也可以设置为模板

#### 类模板
使用类似于函数模板，需要注意模板的嵌套

#### 4.可变参数模板
1. 模板参数包
```
template<typename .. Args> class tuple;//tuple是元祖的意思，模板参数就是模板参数包
```
args被称为模板参数包，表示可以接受任意多个参数作为模板参数，编译器将多个模板参数打包为单个的模板参数包

2. 函数参数包
```
template <typename ...T> void f(T...args);//args就是函数参数包
```
函数参数表必须唯一，且是函数的最后一个参数

当使用参数包时，省略号位于参数名称的右侧，表示立即展开该参数，也即解包

3. 可变模板参数的优势

>参数类型：在推导时已知 

>参数个数：在编译时已确定参数个数