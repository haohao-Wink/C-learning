## 1. 设A为test类的对象且赋有初值,则语句test B(A); 表示。

答案：将对象A复制给对象B。

分析：执行test B(A);语句相当于调用了默认复制构造函数，将A对象的属性复制给B对象。

--- -

## 2. 利用“对象名.成员变量”形式访问的对象成员仅限于被声明为 (1)的成员；若要访问其他成员变量，需要通过 (2) 函数或 (3) 函数。

答案：(1) public (2) 成员函数 (3)友元函数

分析：类体内的数据成员可声明为公有的、私有的和保护的，公有的数据成员可利用“对象名.成员变量”
形式来进行访问；私有的数据成员能被类中的其他成员函数或友元函数所调用；保护的数据成员可以在类
体中使用，也可以在派生类中使用，但不能在其他类外通过对象使用。

---
## 3. 浅拷贝与深拷贝

答：
1. 浅拷贝：比如拷贝类对象时，对象含有指针成员，只是拷贝指针变量自身，这样新旧对象的指针还是指向同一内存区域；

2. 深拷贝：同理，对象含有指针成员，拷贝时不仅拷贝指针变量，还重新在内存中为新对象开辟一块内存区域，将原对象次指针成员所指向的内存数据都拷贝到新开辟的内存区域。

---
## 4. 请你来回答一下new和malloc的区别？？？
1. new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；
2. new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。
3. new不仅分配一段内存，而且会调用构造函数，malloc不会。
4. new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。
5. new是一个操作符可以重载，malloc是一个库函数。
6. malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。
7. new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。
8. 申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。

---
## 5.请你说一说内存溢出和内存泄漏
### 内存溢出
1. 指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误

2. 内存溢出原因：内存中加载的数据量过于庞大，如一次从数据库取出过多数据集合类中有对对象的引用，使用完后未清空，使得不能回收代码中存在死循环或循环产生过多重复的对象实体使用的第三方软件中的BUG启动参数内存值设定的过小

### 内存泄漏
1. 内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

#### 2. 内存泄漏的分类：
1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。

2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用
相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。

3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露

**野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针**